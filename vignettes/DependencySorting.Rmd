---
title: "Join Dependency Sorting"
author: "John Mount"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Join Dependency Sorting}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# note: employeeAndDate is likely built as a cross-product
#       join of an employee table and set of dates of interest
#       before getting to the join controller step.  We call
#       such a table "row control" or "experimental design."
# Normally tDesc is produced by inspecting tables using
# replyr::tableDescription() and then limiting the keys
# column down to the correct specification.
# For this example we just type tDesc in directly.
tDesc <- data.frame(tableName= c('employeeAndDate',
                                 'orgtable',
                                 'revenue',
                                 'activity'),
                    handle= I(list(NULL, NULL, NULL, NULL)),
                    columns= I(list(c('id', 'date'),
                                  c('id', 'date', 'dept'),
                                  c('date', 'dept', 'rev'),
                                  c('id', 'date', 'hours'))),
                    keys =  I(list(c('id'='id', 'date'='date'),
                                 c('id'='id', 'date'='date'),
                                 c('date'='date', 'dept'='dept'),
                                 c('id'='id', 'date'='date'))),
                    colClass= I(list(c('character', 'numeric'),
                                   c('character', 'character', 'character'),
                                   c('numeric', 'character', 'numeric'),
                                   c('character', 'numeric', 'numeric'))),
                    sourceClass= 'None',
                    isEmpty= FALSE,
                    stringsAsFactors = FALSE)
# mess up order
tDesc <- tDesc[c(1,4,3,2), , drop=FALSE]
rownames(tDesc) <- NULL
tDesc <- dplyr::as_data_frame(tDesc)
```

One of the great advantages to specifying complicated sequences of operations in data (rather than in code) is: it is easier to transform and extend data.

For example suppose we have built (using `replyr::tableDescription()`) a description of tables we need to left-join (please see `vignette('joinController', package= 'replyr')` for details).  But, suppose we haven't worked out the order to perform the joins in. 

In this case we can use a tool to specify a usable join order.

First let's assume we have our table descriptions (as described in `vignette('joinController', package= 'replyr')`) and in this case the tables descriptions are the following:

```{r intro}
suppressPackageStartupMessages(library("dplyr"))
library("replyr")

print(tDesc[, c('tableName', 'keys', 'columns'), ])
```

This is more legible if we turn it into a column join plan.

```{r plan1}
columnJoinPlan <- buildJoinPlan(tDesc, check= FALSE)
print(columnJoinPlan[, c('tableName', 'resultColumn', 'isKey')])
```

Now suppose we know that we want the table "`employeeAndDate`" to be the left-most table in our left join sequence.  

Not all table orders are valid left join plans.  The required invariant of a valid left join plan is: except for the left-most table all key values for a given table must be known before a given table can be joined in.  Our current plan (with the tables ordered as presented in `columnJoinPlan`) fails this condition:

```{r check1}
print(paste("issues:", inspectDescrAndJoinPlan(tDesc, columnJoinPlan)))
```

This message is saying: when it comes time to join in the "`revenue`" table rows do not yet have values for the "`dept`" key column (so we can't do the join in that order).

These requirements give us table to table pre-conditions: tables that instantiate values for keys must come before tables using those values as keys.  These pre-conditions give us a directed graph with arrows meaning "must be joined earlier than."  For example we can compute the join path dependencies *and* re-order the join plan to be realizable as follows (assuming the `igraph` package is available do perform the topological sorting and plotting).

```{r sort}
if(requireNamespace('igraph', quietly = TRUE)) {
  sorted <- topoSortTables(columnJoinPlan, 'employeeAndDate')
  plot(sorted$dependencyGraph)
}
```

Note that in the above graph we capture that the "`revenue`" table must be joined after the "`orgtable`" (as "`orgtable`" is our mapping from employees to departments).   We could work on the legibility of the above graph using `igraph` controls, but I feel that it is just as well to move on to the detailed `DiagrammeR` based left join diagrams.

And (again assuming we have the `igraph` package), we have a new `columnJoinPlan` that passes checks:

```{r check2}
if(requireNamespace('igraph', quietly = TRUE)) {
  columnJoinPlan <- sorted$columnJoinPlan
  print(paste("issues:", inspectDescrAndJoinPlan(tDesc, columnJoinPlan)))
}
```

The new `columnJoinPlan` can be re-plotted (needs the suggested packages:  `DiagrammeR`, `htmlwidgets`, `webshot`, and `magick`): 

```{r render1}
pngFileName <- 'jPlan.png'
diagramPNG <- NULL
have <- c(
  requireNamespace('igraph', quietly = TRUE),
  requireNamespace('DiagrammeR', quietly = TRUE),
  requireNamespace('htmlwidgets', quietly = TRUE),
  requireNamespace('webshot', quietly = TRUE),
  requireNamespace('magick', quietly = TRUE)
)
if(all(have)) {
  diagramPNG <- columnJoinPlan %>%
    makeJoinDiagramSpec() %>%
    renderJoinDiagram(pngFileName = pngFileName)
}
```

```{r showimg, results='asis', echo=FALSE}
if(!is.null(diagramPNG)) {
  cat(paste0('<center><img src="', pngFileName, '" width="600" border="0"></center>'))
}
```


And the new `columnJoinPlan` is ready to be executed:

```{r steps}
if(requireNamespace('igraph', quietly = TRUE)) {
  res <- executeLeftJoinPlan(tDesc, columnJoinPlan, dryRun = TRUE)
}
```

And this is how we use tools to do the heavy lifting in building a left join plan:

  * The table descriptions can be largely built by `replyr::tableDescription()`.
  * The column names can be disambiguated by `replyr::buildJoinPlan()`.
  * The user can then export `columnJoinPlan` and refine the definition of table keys using an editor or spreadsheet software.
  * `replyr::topoSortTables()` can then reorder `columnJoinPlan` to bring the tables together in a realizable order.
  * `replyr::makeJoinDiagramSpec() %>% replyr::renderJoinDiagram()` can then produce and capture a detailed diagram of the final join plan.
  * Finally `replyr::executeLeftJoinPlan()` can execute the join plan with diagnostics.

